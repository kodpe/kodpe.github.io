<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Billard 3D minimaliste</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            background: #111;
            overflow: hidden;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        .ball-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #32cd32;
            /* pointer-events: none; */
            transform: translate(-50%, -50%);
            z-index: 1;
            overflow: hidden;
            /* border: 2px solid #bbbbbb; */
            border: 2px solid #ff0000;
        }
        .ball-indicator:hover {
            border: 3px solid white;
        }
        .ball-indicator img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';

        // --- Config ---
        const BALL_COUNT = 10;
        const TABLE_WIDTH = 16, TABLE_DEPTH = 8.5;
        const BALL_RADIUS = 0.25;
        const FRICTION = 0.995;
        // const MAX_SPEED = 0.12;
        const MAX_SPEED = 0.02;

        // --- Scene / Camera / Renderer ---
        const canvas = document.getElementById('canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b0b0b);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, 12);
        camera.lookAt(0, 0, 0);

        scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 0.8));
        const dir = new THREE.DirectionalLight(0xffffff, 0.6);
        dir.position.set(5, 10, 7);
        scene.add(dir);

        // --- Table ---
        const table = new THREE.Mesh(
            new THREE.PlaneGeometry(TABLE_WIDTH, TABLE_DEPTH),
            new THREE.MeshStandardMaterial({ color: 0x073b07, roughness: 0.9 })
        );
        table.rotation.x = -Math.PI / 2;
        scene.add(table);

        // --- Balls ---
        const colors = [0xffffff, 0xff0000, 0x0000ff, 0xffff00, 0xff8800, 0x00ff88, 0x8800ff, 0x00ffff, 0xff00aa, 0x889900];
        const balls = [];
        const ballGeo = new THREE.SphereGeometry(BALL_RADIUS, 24, 24);

        function randomPos() {
            return {
                x: (Math.random() * (TABLE_WIDTH - 2 * BALL_RADIUS)) - (TABLE_WIDTH / 2 - BALL_RADIUS),
                z: (Math.random() * (TABLE_DEPTH - 2 * BALL_RADIUS)) - (TABLE_DEPTH / 2 - BALL_RADIUS)
            };
        }

        for (let i = 0; i < BALL_COUNT; i++) {
            // const mesh = new THREE.Mesh(ballGeo, new THREE.MeshStandardMaterial({ color: colors[i % colors.length] }));
            const mesh = new THREE.Mesh(ballGeo, new THREE.MeshBasicMaterial({ color: 0x32cd32 }));
            // const mesh = new THREE.Mesh(ballGeo, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            mesh.visible = false;
            // mesh.material.transparent = true;
            // mesh.material.opacity = 0.2;
            const pos = randomPos();
            mesh.position.set(pos.x, BALL_RADIUS, pos.z);
            scene.add(mesh);
            const angle = Math.random() * Math.PI * 2;

            // --- Création du div HTML ---
            const div = document.createElement('div');
            div.className = 'ball-indicator';
            const img = document.createElement('img');
            // img.src = '../images/icons/champions/33.png';
            img.src = "https://raw.communitydragon.org/latest/plugins/rcp-be-lol-game-data/global/default/v1/champion-icons/221.png";
            div.appendChild(img);
            document.body.appendChild(div);

            balls.push({
                mesh,
                pos,
                vel: { x: Math.cos(angle) * MAX_SPEED, z: Math.sin(angle) * MAX_SPEED },
                radius: BALL_RADIUS,
                div
            });
        }

        // --- Physics (2D collisions) ---
        function stepPhysics() {
            for (const b of balls) {
                const jitterFactor = 0.005;
                if (Math.abs(b.vel.x) < jitterFactor && Math.abs(b.vel.z) < jitterFactor) {
                    const angle = Math.random() * Math.PI * 2;
                    b.vel.x += Math.cos(angle) * MAX_SPEED;
                    b.vel.z += Math.sin(angle) * MAX_SPEED;
                }
                b.pos.x += b.vel.x;
                b.pos.z += b.vel.z;

                const minX = -TABLE_WIDTH / 2 + b.radius, maxX = TABLE_WIDTH / 2 - b.radius;
                const minZ = -TABLE_DEPTH / 2 + b.radius, maxZ = TABLE_DEPTH / 2 - b.radius;

                if (b.pos.x < minX) { b.pos.x = minX; b.vel.x *= -1; }
                if (b.pos.x > maxX) { b.pos.x = maxX; b.vel.x *= -1; }
                if (b.pos.z < minZ) { b.pos.z = minZ; b.vel.z *= -1; }
                if (b.pos.z > maxZ) { b.pos.z = maxZ; b.vel.z *= -1; }

                b.vel.x *= FRICTION;
                b.vel.z *= FRICTION;

                b.mesh.position.x = b.pos.x;
                b.mesh.position.z = b.pos.z;
            }

            // ball-ball simple collisions
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const A = balls[i], B = balls[j];
                    const dx = B.pos.x - A.pos.x, dz = B.pos.z - A.pos.z;
                    const dist2 = dx * dx + dz * dz, minDist = (A.radius + B.radius);
                    if (dist2 < minDist * minDist) {
                        const dist = Math.sqrt(dist2) || 1e-6;
                        const nx = dx / dist, nz = dz / dist;
                        const overlap = 0.5 * (minDist - dist);
                        A.pos.x -= nx * overlap; A.pos.z -= nz * overlap;
                        B.pos.x += nx * overlap; B.pos.z += nz * overlap;
                    }
                }
            }
        }

        // --- Update div positions ---
        function updateDivs() {
            for (const b of balls) {
                const vector = new THREE.Vector3(b.pos.x, BALL_RADIUS, b.pos.z);
                vector.project(camera);
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                b.div.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
            }
        }

        // --- Render Loop ---
        function resize() {
            const w = canvas.clientWidth, h = canvas.clientHeight;
            if (canvas.width !== w * window.devicePixelRatio || canvas.height !== h * window.devicePixelRatio) {
                renderer.setSize(w, h, false);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            }
        }
        
        let camAngle = 0;
        const camRadius = 12;      // distance caméra → centre
        const camHeight = 10;      // hauteur caméra
        const camSpeed = 0.002;    // vitesse rotation
        function updateAutomationCamera() {
            // --- Rotation automatique de la caméra ---
            camAngle += camSpeed;
            camera.position.x = Math.cos(camAngle) * camRadius;
            camera.position.z = Math.sin(camAngle) * camRadius;
            camera.position.y = camHeight;
            camera.lookAt(0, 0, 0);
        }

        function animate() {
            requestAnimationFrame(animate);

            updateAutomationCamera();
            stepPhysics();
            updateDivs();
            resize();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>

</html>
